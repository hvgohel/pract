package com.dw.pract.controller;

import javax.inject.Inject;
import javax.naming.AuthenticationException;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

import com.dw.pract.dto.ErrorInfo;
import com.dw.pract.exception.AccessDeniedException;
import com.dw.pract.exception.ResourceNotFoundException;
import com.dw.pract.utils.BeanMapper;

/**
 * handle all exceptions generated by the API, and response with a 500.
 * 
 * @author ashvin
 */
public class BaseAPIController {

    private final static Logger LOGGER = LoggerFactory.getLogger(BaseAPIController.class);

    @Inject
    protected BeanMapper beanMapper;

    /**
     * THIS IS A NASTY WORKAROUND TO STOP IE9 CACHING API CALLS.
     * 
     * We can probably setup a spring response intercepter to do this, but I couldn't get it to work. Made a bit harder
     * because we are not using the xml config and mvc namespace.
     * 
     * @param response
     *            a non-cacheable response
     */
    protected void preventCaching(HttpServletResponse response) {
        response.setHeader("Cache-Control", "no-store, no-cache, must-revalidate");
        response.setHeader("Pragma", "no-cache");
    }

    /**
     * AuthenticationException will be handled by this method.
     * 
     * It will log the error statement, sets response code 401 and return the error message and/or error code in the
     * form of ErrorInfo.
     * 
     * @param exception
     *            AuthenticationException instance
     * @return
     */
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    @ExceptionHandler(AuthenticationException.class)
    @ResponseBody
    public ErrorInfo errorHandler(AuthenticationException exception) { // 401
        LOGGER.debug("API failed: ", exception);
        return getErrorInfoObj(exception);
    }

    /**
     * AccessDeniedException will be handled by this method.
     * 
     * It will log the error statement, sets response code 403 and return the error message and/or error code in the
     * form of ErrorInfo.
     * 
     * @param exception
     *            AccessDeniedException instance
     * @return
     */
    @ResponseStatus(HttpStatus.FORBIDDEN)
    @ExceptionHandler(AccessDeniedException.class)
    @ResponseBody
    public ErrorInfo errorHandler(AccessDeniedException exception) { // 403
        LOGGER.debug("API failed: ", exception);
        return getErrorInfoObj(exception);
    }

    /**
     * ResourceNotFoundException will be handled by this method.
     * 
     * It will log the error statement, sets response code 404 and return the error message and/or error code in the
     * form of ErrorInfo
     * 
     * @param exception
     *            ResourceNotFoundException instance
     * @return
     */
    @ResponseStatus(HttpStatus.NOT_FOUND)
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseBody
    public ErrorInfo errorHandler(ResourceNotFoundException exception) { // 404
        LOGGER.debug("API failed: ", exception);
        return getErrorInfoObj(exception);
    }

    /**
     * IllegalArgumentException will be handled by this method.
     * 
     * It will log the error statement, sets response code 400 and return the error message and/or error code in the
     * form of ErrorInfo
     * 
     * @param exception
     *            IllegalArgumentException exception
     * @return
     */
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(IllegalArgumentException.class)
    @ResponseBody
    public ErrorInfo errorHandler(IllegalArgumentException exception) { // 400
        LOGGER.debug("API failed: ", exception);
        return getErrorInfoObj(exception);
    }

    /**
     * IllegalStateExceptions will be handled by this method.
     * 
     * It will log the error statement, sets response code 409 and return the error message and/or error code in the
     * form of ErrorInfo
     * 
     * @param exception
     *            IllegalStateException instance
     * @return
     */
    @ResponseStatus(HttpStatus.CONFLICT)
    @ExceptionHandler({ IllegalStateException.class })
    @ResponseBody
    public ErrorInfo errorHandler(Exception exception) { // 409
        LOGGER.debug("API failed: ", exception);
        return getErrorInfoObj(exception);
    }

    /**
     * Rest of all Exception will be handled by this method.
     * 
     * It will log the error statement, sets response code 500 and return the error message in the form of ErrorInfo
     * 
     * @param exception
     *            Exception instance
     * @return
     */
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public ErrorInfo allErrorHandler(Exception exception) { // 500
        LOGGER.error("API failed: ", exception);
        return new ErrorInfo("Unknown server error");
    }

    /**
     * This method is used to set error message and/or error code from exception.
     * 
     * @param exception
     * @return
     */
    private ErrorInfo getErrorInfoObj(Exception exception) {
        ErrorInfo errorInfo = new ErrorInfo(exception.getMessage());

        // TODO: change package path for ErrorInfo interface, if you have renamed the package name
        if (exception instanceof com.dw.pract.exception.ErrorInfo) {
            errorInfo.setCode(((com.dw.pract.exception.ErrorInfo) exception).getCode());
        }

        return errorInfo;
    }
}
